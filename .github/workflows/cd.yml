name: CD - Automated VPS Pipeline

on:
  workflow_run:
    workflows: ["CI"]
    types:
      - completed
    branches: [ main ]
  schedule:
    # Run automated deployment daily at 2 AM UTC
    - cron: '0 2 * * *'
  workflow_dispatch:
    inputs:
      environment:
        description: 'Deployment environment for automated pipeline'
        required: true
        default: 'staging'
        type: choice
        options:
        - staging
        - production
      force_deploy:
        description: 'Force deployment even if no changes'
        required: false
        default: false
        type: boolean

env:
  DOCKER_IMAGE: leangchhunhut/ecommerce-api

jobs:
  build-image:
    runs-on: ubuntu-latest
    if: ${{ github.event.workflow_run.conclusion == 'success' || github.event_name == 'workflow_dispatch' || github.event_name == 'schedule' || inputs.force_deploy }}
    outputs:
      image-tag: ${{ steps.meta.outputs.tags }}
      image-digest: ${{ steps.build.outputs.digest }}
      should-deploy: ${{ steps.check-changes.outputs.should-deploy }}
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      with:
        fetch-depth: 2  # Need history to check for changes

    - name: Check for changes
      id: check-changes
      run: |
        if [ "${{ github.event_name }}" = "schedule" ]; then
          # For scheduled runs, check if there are new commits since last day
          if git log --since="24 hours ago" --oneline | grep -q .; then
            echo "should-deploy=true" >> $GITHUB_OUTPUT
            echo "üìÖ Scheduled deployment: New commits found"
          else
            echo "should-deploy=false" >> $GITHUB_OUTPUT
            echo "üìÖ Scheduled deployment: No new commits, skipping"
          fi
        elif [ "${{ inputs.force_deploy }}" = "true" ]; then
          echo "should-deploy=true" >> $GITHUB_OUTPUT
          echo "üîÑ Force deployment requested"
        else
          echo "should-deploy=true" >> $GITHUB_OUTPUT
          echo "üöÄ Regular deployment triggered"
        fi

    - name: Set up Docker Buildx
      uses: docker/setup-buildx-action@v3

    - name: Log in to Docker Hub
      uses: docker/login-action@v3
      with:
        username: ${{ secrets.DOCKERHUB_USERNAME }}
        password: ${{ secrets.DOCKERHUB_TOKEN }}

    - name: Extract metadata
      id: meta
      uses: docker/metadata-action@v5
      with:
        images: ${{ env.DOCKER_IMAGE }}
        tags: |
          type=ref,event=branch
          type=sha,prefix={{branch}}-
          type=raw,value=latest,enable={{is_default_branch}}
          type=raw,value=staging,enable={{is_default_branch}}

    - name: Build and push Docker image
      id: build
      uses: docker/build-push-action@v5
      with:
        context: .
        push: true
        tags: ${{ steps.meta.outputs.tags }}
        labels: ${{ steps.meta.outputs.labels }}
        cache-from: type=gha
        cache-to: type=gha,mode=max
        platforms: linux/amd64,linux/arm64

    - name: Run Trivy vulnerability scanner
      uses: aquasecurity/trivy-action@master
      with:
        image-ref: ${{ env.DOCKER_IMAGE }}:latest
        format: 'sarif'
        output: 'trivy-results.sarif'

    - name: Upload Trivy scan results
      uses: github/codeql-action/upload-sarif@v3
      if: always()
      with:
        sarif_file: 'trivy-results.sarif'

  deploy-staging:
    runs-on: ubuntu-latest
    needs: build-image
    if: needs.build-image.outputs.should-deploy == 'true' && (github.ref == 'refs/heads/main' || github.event_name == 'schedule') && (github.event.workflow_run.conclusion == 'success' || github.event.inputs.environment == 'staging' || github.event_name == 'schedule')
    environment: 
      name: staging
      url: http://${{ secrets.STAGING_VPS_HOST }}:3000

    steps:
    - name: Deploy to staging VPS
      uses: appleboy/ssh-action@v1.0.3
      with:
        host: ${{ secrets.STAGING_VPS_HOST }}
        username: ${{ secrets.VPS_USER }}
        key: ${{ secrets.VPS_SSH_KEY }}
        port: ${{ secrets.VPS_PORT || 22 }}
        script: |
          set -e
          echo "üöÄ Deploying to staging..."
          
          cd /opt/ecommerce-api
          
          # Force pull latest staging image
          echo "üê≥ Pulling latest staging image..."
          docker pull ${{ env.DOCKER_IMAGE }}:staging
          
          # Remove existing containers to ensure fresh deployment
          echo "üõë Stopping existing containers..."
          docker-compose -f docker-compose.vps.yml down
          
          # Remove old image to force using latest
          docker rmi ${{ env.DOCKER_IMAGE }}:staging || true
          
          # Pull fresh image again
          docker pull ${{ env.DOCKER_IMAGE }}:staging
          
          # Update docker-compose to use staging image
          sed -i 's|image:.*ecommerce-api.*|image: ${{ env.DOCKER_IMAGE }}:staging|g' docker-compose.vps.yml
          
          # Deploy with staging configuration and pull latest images
          docker-compose -f docker-compose.vps.yml pull api
          docker-compose -f docker-compose.vps.yml up -d --remove-orphans
          
          # Wait for deployment
          sleep 30
          
          # Clean up old images
          docker image prune -f

    - name: Run health check
      run: |
        sleep 20
        max_attempts=5
        attempt=1
        
        while [ $attempt -le $max_attempts ]; do
          echo "Health check attempt $attempt/$max_attempts"
          response=$(curl -s -o /dev/null -w "%{http_code}" http://${{ secrets.STAGING_VPS_HOST }}:3000/api/v1/health || echo "000")
          
          if [ "$response" = "200" ]; then
            echo "‚úÖ Staging health check passed!"
            break
          elif [ $attempt -eq $max_attempts ]; then
            echo "‚ùå Staging health check failed after $max_attempts attempts"
            exit 1
          else
            echo "‚è≥ Waiting 10s before retry..."
            sleep 10
            ((attempt++))
          fi
        done

    - name: Notify deployment status
      uses: 8398a7/action-slack@v3
      if: always()
      with:
        status: ${{ job.status }}
        channel: '#deployments'
        webhook_url: ${{ secrets.SLACK_WEBHOOK }}
        text: |
          Staging deployment ${{ job.status }}!
          Environment: http://${{ secrets.STAGING_VPS_HOST }}:3000

  deploy-production:
    runs-on: ubuntu-latest
    needs: [build-image, deploy-staging]
    if: needs.build-image.outputs.should-deploy == 'true' && success() && (github.event.inputs.environment == 'production' || (needs.deploy-staging.result == 'success' && github.ref == 'refs/heads/main' && github.event_name != 'schedule'))
    environment: 
      name: production
      url: http://${{ secrets.PRODUCTION_VPS_HOST }}:3000

    steps:
    - name: Manual approval required
      uses: trstringer/manual-approval@v1
      with:
        secret: ${{ github.TOKEN }}
        approvers: ${{ vars.PRODUCTION_APPROVERS }}
        minimum-approvals: 1
        issue-title: "Production Deployment Approval Required"
        issue-body: |
          ### Production Deployment Request
          
          **Branch**: ${{ github.ref_name }}
          **Commit**: ${{ github.sha }}
          **Docker Image**: ${{ env.DOCKER_IMAGE }}:latest
          **Requester**: ${{ github.actor }}
          
          **Staging Status**: ‚úÖ Successfully deployed and health checked
          
          Please review and approve this production deployment.

    - name: Deploy to production VPS
      uses: appleboy/ssh-action@v1.0.3
      with:
        host: ${{ secrets.PRODUCTION_VPS_HOST }}
        username: ${{ secrets.VPS_USER }}
        key: ${{ secrets.VPS_SSH_KEY }}
        port: ${{ secrets.VPS_PORT || 22 }}
        script: |
          set -e
          echo "üöÄ Deploying to production..."
          
          cd /opt/ecommerce-api
          
          # Create backup of current deployment
          if docker-compose -f docker-compose.vps.yml ps | grep -q "Up"; then
            echo "üì¶ Creating backup of current deployment..."
            docker tag ${{ env.DOCKER_IMAGE }}:latest ${{ env.DOCKER_IMAGE }}:backup-$(date +%Y%m%d-%H%M%S)
          fi
          
          # Force pull latest production image
          echo "üê≥ Pulling latest production image..."
          docker pull ${{ env.DOCKER_IMAGE }}:latest
          
          # Remove old image to ensure fresh deployment
          docker rmi ${{ env.DOCKER_IMAGE }}:latest || true
          
          # Pull fresh image again
          docker pull ${{ env.DOCKER_IMAGE }}:latest
          
          # Update docker-compose to use latest image
          sed -i 's|image:.*ecommerce-api.*|image: ${{ env.DOCKER_IMAGE }}:latest|g' docker-compose.vps.yml
          
          # Deploy with zero-downtime strategy and force pull
          echo "üîÑ Performing rolling update..."
          docker-compose -f docker-compose.vps.yml pull api
          docker-compose -f docker-compose.vps.yml up -d --remove-orphans
          
          # Wait for new containers to be ready
          sleep 45
          
          # Verify deployment
          if ! docker-compose -f docker-compose.vps.yml ps | grep -q "Up"; then
            echo "‚ùå Deployment failed - rolling back..."
            docker tag ${{ env.DOCKER_IMAGE }}:backup-$(date +%Y%m%d)* ${{ env.DOCKER_IMAGE }}:latest 2>/dev/null || echo "No backup available"
            docker-compose -f docker-compose.vps.yml up -d
            exit 1
          fi
          
          echo "‚úÖ Production deployment successful!"

    - name: Run production health check
      run: |
        sleep 30
        max_attempts=10
        attempt=1
        
        echo "üîç Running comprehensive production health checks..."
        
        while [ $attempt -le $max_attempts ]; do
          echo "Health check attempt $attempt/$max_attempts"
          
          # Check main health endpoint
          health_response=$(curl -s -o /dev/null -w "%{http_code}" http://${{ secrets.PRODUCTION_VPS_HOST }}:3000/api/v1/health || echo "000")
          
          # Check database health
          db_response=$(curl -s -o /dev/null -w "%{http_code}" http://${{ secrets.PRODUCTION_VPS_HOST }}:3000/api/v1/health/database || echo "000")
          
          # Check API endpoints
          api_response=$(curl -s -o /dev/null -w "%{http_code}" http://${{ secrets.PRODUCTION_VPS_HOST }}:3000/api/v1/categories || echo "000")
          
          if [ "$health_response" = "200" ] && [ "$db_response" = "200" ] && [ "$api_response" = "200" ]; then
            echo "‚úÖ All production health checks passed!"
            echo "   - Health endpoint: $health_response"
            echo "   - Database: $db_response"
            echo "   - API: $api_response"
            break
          elif [ $attempt -eq $max_attempts ]; then
            echo "‚ùå Production health checks failed after $max_attempts attempts"
            echo "   - Health endpoint: $health_response"
            echo "   - Database: $db_response"  
            echo "   - API: $api_response"
            exit 1
          else
            echo "‚è≥ Waiting 15s before retry..."
            sleep 15
            ((attempt++))
          fi
        done

    - name: Post-deployment verification
      run: |
        echo "üß™ Running post-deployment verification..."
        
        # Check Swagger documentation
        swagger_response=$(curl -s -o /dev/null -w "%{http_code}" http://${{ secrets.PRODUCTION_VPS_HOST }}:3000/api/docs || echo "000")
        
        if [ "$swagger_response" = "200" ]; then
          echo "‚úÖ Swagger documentation accessible"
        else
          echo "‚ö†Ô∏è  Warning: Swagger documentation not accessible (HTTP $swagger_response)"
        fi
        
        echo "üéâ Production deployment completed successfully!"

    - name: Clean up old images on production
      uses: appleboy/ssh-action@v1.0.3
      with:
        host: ${{ secrets.PRODUCTION_VPS_HOST }}
        username: ${{ secrets.VPS_USER }}
        key: ${{ secrets.VPS_SSH_KEY }}
        port: ${{ secrets.VPS_PORT || 22 }}
        script: |
          echo "üßπ Cleaning up old Docker images..."
          docker image prune -a -f --filter "until=72h"
          echo "‚úÖ Cleanup completed"

    - name: Notify deployment status
      uses: 8398a7/action-slack@v3
      if: always()
      with:
        status: ${{ job.status }}
        channel: '#deployments'
        webhook_url: ${{ secrets.SLACK_WEBHOOK }}
        text: |
          üöÄ PRODUCTION deployment ${{ job.status }}!
          
          **Environment**: http://${{ secrets.PRODUCTION_VPS_HOST }}:3000
          **API Docs**: http://${{ secrets.PRODUCTION_VPS_HOST }}:3000/api/docs
          **Commit**: ${{ github.sha }}
          **Branch**: ${{ github.ref_name }}
          **Deployed by**: ${{ github.actor }}