name: Direct VPS Deploy

on:
  workflow_dispatch:
    inputs:
      environment:
        description: 'Target environment'
        required: true
        default: 'production'
        type: choice
        options:
        - production
        - staging
      skip_tests:
        description: 'Skip CI tests (use with caution)'
        required: false
        default: false
        type: boolean

env:
  DOCKER_IMAGE: leangchhunhut/ecommerce-api

jobs:
  run-ci-tests:
    runs-on: ubuntu-latest
    if: ${{ !inputs.skip_tests }}
    
    services:
      postgres:
        image: postgres:15-alpine
        env:
          POSTGRES_PASSWORD: test123
          POSTGRES_USER: test
          POSTGRES_DB: ecommerce_test
        ports:
          - 5432:5432
        options: >-
          --health-cmd pg_isready
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Use Node.js 20.x
      uses: actions/setup-node@v4
      with:
        node-version: '20.x'
        cache: 'npm'

    - name: Install dependencies
      run: npm ci

    - name: Run linting
      run: npm run lint

    - name: Build application
      run: npm run build

    - name: Run unit tests
      run: npm run test
      env:
        DB_HOST: localhost
        DB_PORT: 5432
        DB_USERNAME: test
        DB_PASSWORD: test123
        DB_NAME: ecommerce_test
        NODE_ENV: test

  build-and-deploy:
    runs-on: ubuntu-latest
    needs: run-ci-tests
    if: always() && (needs.run-ci-tests.result == 'success' || inputs.skip_tests)
    environment:
      name: ${{ inputs.environment }}
      url: http://${{ secrets.VPS_HOST }}:3000
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Set up Docker Buildx
      uses: docker/setup-buildx-action@v3

    - name: Log in to Docker Hub
      uses: docker/login-action@v3
      with:
        username: ${{ secrets.DOCKERHUB_USERNAME }}
        password: ${{ secrets.DOCKERHUB_TOKEN }}

    - name: Extract metadata
      id: meta
      uses: docker/metadata-action@v5
      with:
        images: ${{ env.DOCKER_IMAGE }}
        tags: |
          type=ref,event=branch
          type=sha,prefix={{branch}}-
          type=raw,value=latest,enable={{is_default_branch}}
          type=raw,value=${{ inputs.environment }},enable=true
        labels: |
          org.opencontainers.image.title=E-commerce API (${{ inputs.environment }})
          org.opencontainers.image.description=Direct deployment to ${{ inputs.environment }}
          deployment.environment=${{ inputs.environment }}
          deployment.timestamp=${{ github.run_id }}

    - name: Build and push Docker image
      uses: docker/build-push-action@v5
      with:
        context: .
        platforms: linux/amd64
        push: true
        tags: ${{ steps.meta.outputs.tags }}
        labels: ${{ steps.meta.outputs.labels }}
        cache-from: type=gha,scope=vps-deploy
        cache-to: type=gha,mode=max,scope=vps-deploy
        build-args: |
          BUILD_DATE=${{ fromJSON(steps.meta.outputs.json).labels['org.opencontainers.image.created'] }}
          VCS_REF=${{ github.sha }}
          ENVIRONMENT=${{ inputs.environment }}

    - name: Deploy to ${{ inputs.environment }} VPS
      uses: appleboy/ssh-action@v1.0.3
      with:
        host: ${{ secrets.VPS_HOST }}
        username: ${{ secrets.VPS_USER }}
        key: ${{ secrets.VPS_SSH_KET }}
        port: ${{ secrets.VPS_PORT || 22 }}
        timeout: 300s
        script: |
          set -e  # Exit on error
          
          ENVIRONMENT="${{ inputs.environment }}"
          DOCKER_IMAGE="${{ env.DOCKER_IMAGE }}"
          
          echo "üöÄ Starting direct deployment to $ENVIRONMENT..."
          echo "üìä Deployment Info:"
          echo "   - Environment: $ENVIRONMENT"
          echo "   - Image: $DOCKER_IMAGE:$ENVIRONMENT"
          echo "   - Commit: ${{ github.sha }}"
          echo "   - Branch: ${{ github.ref_name }}"
          echo "   - Triggered by: ${{ github.actor }}"
          
          # Pre-deployment checks
          echo "üîç Running pre-deployment checks..."
          
          if [ ! -d "/opt/ecommerce-api" ]; then
            echo "‚ùå Deployment directory /opt/ecommerce-api not found!"
            echo "Please run: chmod +x scripts/vps-setup.sh && ./scripts/vps-setup.sh"
            exit 1
          fi
          
          cd /opt/ecommerce-api
          echo "üìÅ Working directory: $(pwd)"
          
          # Create .env file from GitHub Secrets
          echo "üìù Creating .env file from GitHub Secrets..."
          cat > .env << EOF
# Generated from GitHub Secrets - $(date)
DB_HOST=localhost
DB_PORT=5432
DB_USERNAME=postgres
DB_PASSWORD=${{ secrets.DB_PASSWORD }}
DB_NAME=ecommerce_db
REDIS_HOST=localhost
REDIS_PORT=6379
JWT_SECRET=${{ secrets.JWT_SECRET }}
JWT_EXPIRES_IN=24h
CORS_ORIGIN=http://localhost:3000,https://yourdomain.com
NODE_ENV=production
EOF
          echo "‚úÖ Environment file created successfully"
          
          # Verify docker-compose file
          if [ ! -f "docker-compose.vps.yml" ]; then
            echo "‚ùå docker-compose.vps.yml not found!"
            echo "Please ensure VPS setup is complete."
            exit 1
          fi
          
          # Check Docker service
          if ! docker info > /dev/null 2>&1; then
            echo "‚ùå Docker is not running!"
            echo "Please start Docker: sudo systemctl start docker"
            exit 1
          fi
          
          # Check Redis service
          if ! redis-cli ping > /dev/null 2>&1; then
            echo "‚ùå Redis is not running!"
            echo "Please start Redis: sudo systemctl start redis-server"
            exit 1
          fi
          
          # Stop existing container if running
          if docker ps | grep -q "ecommerce-api"; then
            echo "üì¶ Stopping existing container..."
            docker stop ecommerce-api || true
            docker rm ecommerce-api || true
          fi
          
          # Pull latest changes from repository
          echo "üì• Pulling latest code from repository..."
          git fetch origin
          git reset --hard origin/main
          
          # Force pull Docker image for target environment
          echo "üê≥ Force pulling Docker image: $DOCKER_IMAGE:$ENVIRONMENT"
          
          # Remove old image first to ensure we get the latest
          docker rmi $DOCKER_IMAGE:$ENVIRONMENT 2>/dev/null || true
          
          # Pull fresh image
          if docker pull $DOCKER_IMAGE:$ENVIRONMENT; then
            echo "‚úÖ Successfully pulled $DOCKER_IMAGE:$ENVIRONMENT"
          else
            echo "‚ö†Ô∏è  Failed to pull $DOCKER_IMAGE:$ENVIRONMENT, trying latest..."
            docker rmi $DOCKER_IMAGE:latest 2>/dev/null || true
            docker pull $DOCKER_IMAGE:latest
            docker tag $DOCKER_IMAGE:latest $DOCKER_IMAGE:$ENVIRONMENT
            echo "‚úÖ Using latest image tagged as $ENVIRONMENT"
          fi
          
          # Download latest docker-compose.vps.yml
          echo "üì• Downloading latest docker-compose.vps.yml..."
          curl -o docker-compose.vps.yml https://raw.githubusercontent.com/${{ github.repository }}/main/docker-compose.vps.yml
          
          # Deploy using docker-compose with environment file
          echo "üîÑ Starting services with docker-compose..."
          docker-compose -f docker-compose.vps.yml down || true
          DOCKER_IMAGE_TAG=$ENVIRONMENT docker-compose -f docker-compose.vps.yml up -d
          
          # Wait for services to be ready
          echo "‚è≥ Waiting for services to start (45s)..."
          sleep 45
          
          # Verify deployment
          echo "üîç Verifying deployment..."
          if ! docker ps | grep -q "ecommerce-api.*Up"; then
            echo "‚ùå Deployment verification failed!"
            echo "üìã Container status:"
            docker ps -a | grep ecommerce-api
            echo "üìã Container logs:"
            docker logs ecommerce-api --tail=50
            exit 1
          fi
          
          # Clean up old images (keep last 3)
          echo "üßπ Cleaning up old Docker images..."
          docker image prune -f
          
          echo "‚úÖ Direct deployment to $ENVIRONMENT completed successfully!"
          echo "üåê Application should be available at: http://$(hostname -I | awk '{print $1}'):3000"

    - name: Comprehensive Health Check
      run: |
        VPS_HOST="${{ secrets.VPS_HOST }}"
        ENVIRONMENT="${{ inputs.environment }}"
        
        echo "üîç Running comprehensive health checks for $ENVIRONMENT environment..."
        
        # Wait for application to fully start
        sleep 45
        
        max_attempts=8
        attempt=1
        all_passed=true
        
        while [ $attempt -le $max_attempts ]; do
          echo "Health check attempt $attempt/$max_attempts"
          
          # Check main health endpoint
          health_response=$(curl -s -o /dev/null -w "%{http_code}" http://$VPS_HOST:3000/api/v1/health || echo "000")
          
          # Check database health
          db_response=$(curl -s -o /dev/null -w "%{http_code}" http://$VPS_HOST:3000/api/v1/health/database || echo "000")
          
          # Check API functionality
          api_response=$(curl -s -o /dev/null -w "%{http_code}" http://$VPS_HOST:3000/api/v1/categories || echo "000")
          
          # Check Swagger docs
          swagger_response=$(curl -s -o /dev/null -w "%{http_code}" http://$VPS_HOST:3000/api/docs || echo "000")
          
          echo "Response codes - Health: $health_response | DB: $db_response | API: $api_response | Docs: $swagger_response"
          
          if [ "$health_response" = "200" ] && [ "$db_response" = "200" ] && [ "$api_response" = "200" ]; then
            echo "‚úÖ All critical health checks passed!"
            if [ "$swagger_response" = "200" ]; then
              echo "‚úÖ Swagger documentation is also accessible"
            else
              echo "‚ö†Ô∏è  Warning: Swagger docs not accessible (non-critical)"
            fi
            all_passed=true
            break
          elif [ $attempt -eq $max_attempts ]; then
            echo "‚ùå Health checks failed after $max_attempts attempts"
            all_passed=false
            break
          else
            echo "‚è≥ Waiting 15s before retry..."
            sleep 15
            ((attempt++))
          fi
        done
        
        if [ "$all_passed" = "false" ]; then
          echo "‚ùå $ENVIRONMENT deployment health check failed!"
          exit 1
        fi
        
        echo "üéâ $ENVIRONMENT deployment health check completed successfully!"
        echo "üåê Application URLs:"
        echo "   - API: http://$VPS_HOST:3000/api/v1"
        echo "   - Health: http://$VPS_HOST:3000/api/v1/health"
        echo "   - Docs: http://$VPS_HOST:3000/api/docs"

    - name: Deployment Summary
      if: always()
      run: |
        ENVIRONMENT="${{ inputs.environment }}"
        VPS_HOST="${{ secrets.VPS_HOST }}"
        
        echo "üìã Direct VPS Deployment Summary"
        echo "================================="
        echo "Environment: $ENVIRONMENT"
        echo "VPS Host: $VPS_HOST"
        echo "Docker Image: ${{ env.DOCKER_IMAGE }}:$ENVIRONMENT"
        echo "Commit: ${{ github.sha }}"
        echo "Branch: ${{ github.ref_name }}"
        echo "Triggered by: ${{ github.actor }}"
        echo "Job Status: ${{ job.status }}"
        echo "Tests Skipped: ${{ inputs.skip_tests }}"
        
        if [ "${{ job.status }}" = "success" ]; then
          echo ""
          echo "‚úÖ Direct deployment to $ENVIRONMENT completed successfully!"
          echo "üåê Application is available at: http://$VPS_HOST:3000"
          echo "üìö API Documentation: http://$VPS_HOST:3000/api/docs"
        else
          echo ""
          echo "‚ùå Direct deployment to $ENVIRONMENT failed!"
          echo "Please check the logs above for error details."
        fi
        
        echo "================================="